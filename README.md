# Bet Maker

Сервис позволяет создавать [события](#событие-event), на которые можно делать [ставки](#ставка-bet), и в дальнейшем
отслеживать их статус.

## Событие (Event)

На события можно делать [ставки](#ставка-bet). Событие может находиться в одном из 3 статусов:

- Ещё не сыграла (`PENDING`);
- Выиграла (`WIN`);
- Проиграла (`LOSE`);

Сделать ставку не получиться, если событие находиться в одном из конечных статусов (`WIN`, `LOSE`).

## Ставка (Bet)

Можно делать сколь угодно ставок на одно и то же [событие](#событие-event). Важно, чтобы событие было в неконечном
статусе (`WIN`, `LOSE`).

Сумма ставки обязательно должна быть положительным
числом.

## Задание

Задание пока что не прикрепляю, чтобы случайно не распространить решение.

### Размышления по поводу задания

Я не согласен со следующим высказыванием в задании:
> События как таковые хранить не требуется, мы будем работать только с их идентификаторами.

Если события будут храниться в ставках, то очень просто получить несогласованное состояние. Например, событие N
завершилось и на это событие было пару ставок. Вызван метод на обновлении статуса события N, в этот момент меняются
статусы у ставок. До завершения метода на обновления статуса вызывается метод на создание еще одной ставки на событие
N. В итоге, пара ставок имеют конечные статусы (выиграла, проиграла), а одна ставка создалась позднее и имеет неконечный
статус (ещё не сыграла). Я предлагаю работать с событием, как с обычной сущностью и добавить метод создания, что
дополнительно упростит архитектуру и понимание предметной области.
Я вижу процесс следующим образом:

1. Создание события;
2. Создание ставок на события;
3. Завершение события, сменой статуса;

---
Так же я предлагаю изменить метод создания ставки `POST /bets`. Метод работает с деньгами, поэтому важно, чтобы из-за
проблем (например, сетевых) не случилось создание двух одинаковых ставок. Я предлагаю реализовать идемпотентность
следующим образом: пусть клиент на своей стороне создает идентификатор ставки (UUID) и отправляет его в запрос. В таком
случае, приложение просто убедится в том, что такая ставка уже есть и не будет создавать ее повторно. Так же не
требуется прикреплять в ответ идентификатор ставки, потому что клиент и так его знает.

---

Дополнительные НФТ.

1. За какое время запрос должен быть обработан на серверной стороне?
   > запрос должен быть обработан не более чем за 100мс.
2. Какое количество событий и ставок планируется хранить?
   > кол-во событий — порядка 10000.

## Реализовано

- [x] API
- [x] Миграции для базы данных
- [x] Логирование
- [x] Тестирование
- [x] Code-style
- [x] Сборка приложения

## Запуск

```shell
docker compose --project-name test --file deployment/docker-compose.yml up
```

> Важно! После того как база данных поднялась, требуется применить [миграции](#миграции).

**Dockerfile** и **docker-compose** файлы лежат в директории [deployment](deployment).

### Переменные окружения

| Переменная окружения | Описание                          | Значение по умолчанию                                  |
|----------------------|-----------------------------------|--------------------------------------------------------|
| DB_DATABASE          | Название базы данных              | bet-maker                                              |
| DB_USER              | Имя пользователя базы данных      | test                                                   |
| DB_PASSWORD          | Пароль пользователя базы данных   | test                                                   |
| DB_PORT              | Порт базы данных                  | 6432                                                   |
| APPLICATION_PORT     | Порт приложения                   | 80                                                     |

### Миграции

Установить переменные окружения в терминале и выполнить скрипт для установки миграций.

```shell
export DB_DSN=postgresql+asyncpg://test:test@localhost:6432/bet-maker
alembic upgrade head
```

## Локальное окружение

Подготовка локального окружения:

1. Установка всех зависимостей

```shell
pip install -r requirements.txt
pip install -r requirements-test.txt
pip install -r requirements-dev.txt
```

2. Установка pre-commit хуков

```shell
pre-commit install
```

### Выполнение проверок перед каждым коммитом

Перед каждым git commit [pre-commit](https://pre-commit.com/) выполняет следующие действия:

- Удаление ненужных пробелов
- Добавление пустой строки в конце файла
- Запуск [code-style проверок](#проверка-code-style)
- Запуск [тестов](#запуск-тестов)

В случае неуспешного прохождения проверок коммит не будет создан.

Конфигурация pre-commit находится в файле [.pre-commit-config.yaml](.pre-commit-config.yaml).

Чтобы выполнить проверку вручную можно вызвать команду:

```shell
pre-commit run --all-files
```

### Проверка code-style

Проверка code-style происходит с помощью утилиты `Ruff`.
Конфигурация находится в [pyproject.toml](pyproject.toml). Подробнее про настройку можно прочесть
в [документации Ruff](https://docs.astral.sh/ruff/configuration/).

Для запуска проверки code-style требуется выполнить команду:

```shell
ruff check .
```

### Запуск тестов

Тесты написаны на базе фреймворка `pytest`. Конфигурация находится в [pyproject.toml](pyproject.toml). Тесты расположены
в директории [tests](tests).

Для запуска тестов требуется выполнить команду:

```shell
python -m pytest
```
